<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Subway Mobile</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; font-family: sans-serif; }
        #ui { position: absolute; top: 10px; left: 10px; color: #fff; z-index: 10; }
        #score { font-size: 30px; color: gold; }
    </style>
</head>
<body>
    <div id="ui"><div id="score">0</div></div>
    <script src="https://cdnjs.cloudflare.com"></script>
    <script>
        let scene, camera, renderer, player;
        let score = 0, isGameOver = false, speed = 0.7;
        let lanes = [-2.5, 0, 2.5], currentLane = 1;
        let obstacles = [], coins = [];
        let touchStartX = 0, touchStartY = 0;

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000, 10, 120);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            player = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 1), new THREE.MeshPhongMaterial({color: 0x00d4ff}));
            player.position.set(lanes[currentLane], 0.75, 0);
            scene.add(player);

            const road = new THREE.Mesh(new THREE.PlaneGeometry(10, 2000), new THREE.MeshPhongMaterial({color: 0x111}));
            road.rotation.x = -Math.PI/2;
            scene.add(road);

            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            // УПРАВЛЕНИЕ ДЛЯ ТЕЛЕФОНА (СВАЙПЫ)
            window.addEventListener('touchstart', e => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            });

            window.addEventListener('touchend', e => {
                let x = e.changedTouches[0].screenX - touchStartX;
                let y = e.changedTouches[0].screenY - touchStartY;
                if (Math.abs(x) > Math.abs(y)) {
                    if (x > 30 && currentLane < 2) currentLane++;
                    else if (x < -30 && currentLane > 0) currentLane--;
                } else {
                    if (y < -30 && player.position.y <= 0.8) jump();
                }
            });

            // УПРАВЛЕНИЕ ДЛЯ ПК
            window.addEventListener('keydown', e => {
                if(e.key === "ArrowLeft" && currentLane > 0) currentLane--;
                if(e.key === "ArrowRight" && currentLane < 2) currentLane++;
                if(e.key === " " && player.position.y <= 0.8) jump();
            });

            spawn();
            animate();
        }

        function jump() {
            let p = 0.3;
            let j = setInterval(() => {
                player.position.y += p; p -= 0.02;
                if(player.position.y <= 0.75) { player.position.y = 0.75; clearInterval(j); }
            }, 20);
        }

        function spawn() {
            if(isGameOver) return;
            let lane = lanes[Math.floor(Math.random()*3)];
            let obj = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 5), new THREE.MeshPhongMaterial({color: 0xff3333}));
            obj.position.set(lane, 1, -100);
            scene.add(obj);
            obstacles.push(obj);
            setTimeout(spawn, 1000);
        }

        function animate() {
            if(isGameOver) return;
            requestAnimationFrame(animate);
            player.position.x = THREE.MathUtils.lerp(player.position.x, lanes[currentLane], 0.2);
            obstacles.forEach((o, i) => {
                o.position.z += speed;
                if(Math.abs(o.position.z - player.position.z) < 2 && Math.abs(o.position.x - player.position.x) < 1.2 && player.position.y < 2) {
                    isGameOver = true; alert("GAME OVER! Score: " + score); location.reload();
                }
                if(o.position.z > 15) { scene.remove(o); obstacles.splice(i, 1); score += 10; document.getElementById('score').innerText = score; }
            });
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>
