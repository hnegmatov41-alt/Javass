<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Subway Runner Mobile</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #87CEEB; touch-action: none; }
        #score { position: absolute; top: 10px; left: 10px; color: yellow; font-size: 30px; font-family: sans-serif; z-index: 10; font-weight: bold; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="score">0</div>
    <script src="https://cdnjs.cloudflare.com"></script>
    <script>
        // Проверка: загрузилась ли библиотека
        window.onload = function() {
            if (typeof THREE === 'undefined') {
                alert("Ошибка загрузки движка. Проверь интернет!");
                return;
            }
            init();
        };

        let scene, camera, renderer, player;
        let score = 0, isGameOver = false;
        let lanes = [-2, 0, 2], currentLane = 1;
        let obstacles = [];
        let touchStart = {x: 0, y: 0};

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // ГОЛУБОЙ ФОН
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Свет
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            const directional = new THREE.DirectionalLight(0xffffff, 1);
            directional.position.set(5, 10, 5);
            scene.add(directional);

            // Игрок (Зеленый куб)
            player = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1.5, 1), 
                new THREE.MeshPhongMaterial({ color: 0x00ff00 })
            );
            player.position.y = 0.75;
            scene.add(player);

            // Дорога (Серый пол)
            const road = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 1000), 
                new THREE.MeshPhongMaterial({ color: 0x444444 })
            );
            road.rotation.x = -Math.PI / 2;
            scene.add(road);

            camera.position.set(0, 5, 10);
            camera.lookAt(0, 1, 0);

            // Управление для ТЕЛЕФОНА
            window.addEventListener('touchstart', e => {
                touchStart.x = e.touches[0].clientX;
                touchStart.y = e.touches[0].clientY;
            }, false);

            window.addEventListener('touchend', e => {
                let dx = e.changedTouches[0].clientX - touchStart.x;
                let dy = e.changedTouches[0].clientY - touchStart.y;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 40 && currentLane < 2) currentLane++;
                    if (dx < -40 && currentLane > 0) currentLane--;
                } else if (dy < -40 && player.position.y <= 0.8) {
                    jump();
                }
            }, false);

            spawn();
            animate();
        }

        function jump() {
            let v = 0.25;
            let j = setInterval(() => {
                player.position.y += v; v -= 0.02;
                if(player.position.y <= 0.75) { player.position.y = 0.75; clearInterval(j); }
            }, 20);
        }

        function spawn() {
            if(isGameOver) return;
            const obs = new THREE.Mesh(
                new THREE.BoxGeometry(2, 2, 4), 
                new THREE.MeshPhongMaterial({ color: 0xff0000 })
            );
            obs.position.set(lanes[Math.floor(Math.random()*3)], 1, -100);
            scene.add(obs);
            obstacles.push(obs);
            setTimeout(spawn, 1500);
        }

        function animate() {
            if(isGameOver) return;
            requestAnimationFrame(animate);

            // Плавный переход между линиями
            player.position.x = THREE.MathUtils.lerp(player.position.x, lanes[currentLane], 0.2);

            // Движение препятствий
            obstacles.forEach((o, i) => {
                o.position.z += 0.6;
                // Столкновение
                if (Math.abs(o.position.z - player.position.z) < 1.5 && 
                    Math.abs(o.position.x - player.position.x) < 1.2 && 
                    player.position.y < 2) {
                    isGameOver = true;
                    alert("GAME OVER! Твой счет: " + score);
                    location.reload();
                }
                if (o.position.z > 15) {
                    scene.remove(o);
                    obstacles.splice(i, 1);
                    score += 10;
                    document.getElementById('score').innerText = score;
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
